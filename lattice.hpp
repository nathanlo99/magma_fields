
#pragma once

#include "error.hpp"
#include "field.hpp"
#include "gmp.hpp"
#include "large_prime_field.hpp"
#include "matrix.hpp"
#include "medium_prime_field.hpp"
#include "prime_poly.hpp"
#include "small_prime_field.hpp"
#include "vector.hpp"
#include "zech_field.hpp"
#include "zech_poly_field.hpp"

#include <array>
#include <cstdint>
#include <iostream>
#include <map>
#include <memory>
#include <utility>
#include <vector>

struct Lattice;
extern std::map<integer_t, Lattice> lattices;

struct Lattice {
  const integer_t p;
  std::vector<std::shared_ptr<AbstractField>> fields;
  Lattice(const integer_t p) : p(p) { add_prime_field(); }

  std::shared_ptr<AbstractField> add_prime_field();
  std::shared_ptr<AbstractField> add_zech_field(const std::string &variable,
                                                const uint64_t k);
  std::shared_ptr<AbstractField>
  add_prime_poly_field(const std::string &variable, const uint64_t k);
  std::shared_ptr<AbstractField>
  add_zech_poly_field(AbstractField *base, const std::string &variable,
                      const uint64_t k);

  std::shared_ptr<AbstractField> add_field(const uint64_t k,
                                           const std::string &_variable = "");

  friend std::ostream &operator<<(std::ostream &os, const Lattice &lattice) {
    for (const auto &field : lattice.fields) {
      os << " - " << field << ": " << std::setw(20) << std::setfill(' ')
         << field_type_to_string(field->type()) << ": ("
         << field->characteristic() << "^" << field->degree() << ") "
         << field->to_string() << std::endl;
    }
    return os;
  }
};

inline void print_lattices(std::ostream &os) {
  os << std::endl;
  os << "------- LATTICES -------" << std::endl;
  for (const auto &[p, lattice] : lattices) {
    os << "Lattice for prime " << p << ": " << std::endl;
    os << lattice << std::endl << std::endl;
  }
  os << "------------------------" << std::endl;
}

inline std::shared_ptr<AbstractField> FiniteField(const integer_t p,
                                                  const uint64_t k = 1) {
  if (p < 0 || !gmp::is_prime(p))
    throw math_error() << "FiniteField expected positive prime, got " << p;
  if (k == 0)
    throw math_error() << "FiniteField expected positive degree, got " << k;
  if (lattices.count(p) == 0)
    lattices.emplace(p, Lattice(p));
  return lattices.at(p).add_field(k);
}

// There are four elements stored in an explicit field embedding:
// 1. The map phi_{E -> F}, as a matrix relating the generators of E and F
//    over P
// 2. The relative generator for F over E
// 3. The vector-space isomorphism between E^{(d)} and F
// 4. The minimal polynomial of the relative generator
template <class PField, class EField, class FField> struct FieldEmbedding {
  using p_field_t = PField;
  using e_field_t = EField;
  using f_field_t = FField;
  using p_field_element_t = typename PField::element_t;
  using e_field_element_t = typename EField::element_t;
  using f_field_element_t = typename FField::element_t;

  const PField &P;
  const EField &E;
  const FField &F;

  // 1. e x f matrix in P representing the map phi_{E -> F}
  Matrix<PField> phi;
  // 2. An element alpha_{F / E} of F such that E[alpha] = F
  f_field_element_t alpha_FE;
  // 3. A vector space isomorphism N encoding the transformation E^{(d)} -> F
  Matrix<PField> psi;
  // 4. The minimal polynomial of alpha_{F/E} over E
  Polynomial<EField> f_FE;

  FieldEmbedding(const PField &P, const EField &E, const FField &F)
      : P(P), E(E), F(F), phi(P), alpha_FE(F.element(F.zero())), psi(P),
        f_FE(E, "x", {E.element(E.zero())}, {}) {}
};

template <class PField, class EField, class FField>
FieldEmbedding<PField, EField, FField> Embed(const PField &P, const EField &E,
                                             const FField &F) {
  FieldEmbedding<PField, EField, FField> result(P, E, F);

  const auto e = E.degree(), f = F.degree();
  assert(f % e == 0);
  const auto d = f / e;

  // 1. Computing prime-field generators
  const auto alpha_E = E.generating_element();
  const auto alpha_F = F.generating_element();
  const auto tau = find_root(E.f.lift(F));
  std::cout << "alpha_E = " << alpha_E << std::endl;
  std::cout << "alpha_F = " << alpha_F << std::endl;
  std::cout << "tau = " << tau << std::endl;

  if (F.g != F.g.var_poly())
    throw math_error("Currently only supports fields generated by w");

  // 2. Computing the matrix phi_{E -> F}
  auto M = Matrix(P, e, f);
  for (size_t i = 0; i < e; ++i) {
    const auto tau_i = F.to_polynomial((tau ^ i).value);
    std::cout << "tau^" << i << " = " << tau_i << std::endl;
    for (size_t j = 0; j < f; ++j) {
      M[i][j] = tau_i[j];
    }
  }
  result.phi = M;
  std::cout << M << std::endl;

  // 3. Finding a generator for F/E
  // If G is contained in E and we already have a generator for F over
  // G, then use that
  // TODO: Implement the above more generally once we have embeddings
  // For now, we just restrict ourselves to fields F with G = P
  const auto alpha_FE = F.generating_element();
  result.alpha_FE = alpha_FE;

  // 4. Compute the vector-space isomorphism E^{(d)} -> F
  Matrix N(P, f, f);
  for (size_t i = 0; i < d; ++i) {
    for (size_t j = 0; j < e; ++j) {
      // Compute \phi_F^{-1}(alpha_FE^i * tau^j)
      const auto alpha_FE_to_i = alpha_FE ^ i;
      const auto tau_to_j = tau ^ j;
      const auto product = alpha_FE_to_i * tau_to_j;
      const auto row = F.to_vector(product);
      N[i * e + j] = row.data;
    }
  }
  result.psi = N;
  std::cout << N << std::endl;

  // 5. Compute the minimal polynomial of alpha_FE over E

  return result;
}

// inline void Embed(const std::shared_ptr<AbstractField> &E,
//                   const std::shared_ptr<AbstractField> &F) {}
